# 基础构建

> 想必各位都想建一个简易的人工象棋自己玩玩吧，那么我们应该怎么做呢？让我们一起看看吧！

此类文章记录了如何徒手撸一个迷你世界的一个中国象棋简易象棋人工智能，阅读完这些文章，你将有能力自己写一个属于你自己的象棋电脑！

## 头脑风暴

首先要知道，要做一个简易的中国象棋人工智能，需要准备什么东西。否则容易越写越乱。
首先，肯定要**有一个象棋棋盘，以及一个方式可以使玩家下棋**，也就是游戏界面，要不然怎么下象棋啊？
其次，我们还需要**有一个简易的人工智能，来和玩家对弈**。

游戏界面可以通过迷你世界的方块来模拟一个，并且我们需要一些棋子方块来模拟棋盘，就像这样子：

![chinesechess](https://s1.ax1x.com/2022/06/18/XLM9mt.png)

**然后我们再写一下脚本，使玩家可以操作象棋棋盘**，就可以实现玩家下棋了，实现了下象棋这一游戏界面。

接着我们需要一个可以和玩家对弈的简易的人工智能，这将通过我们聪慧的大脑写出来，但是人工智能怎么下棋呢？

我们是不是应该让这个简易的人工智能**知道他可以下哪些位置**啊，我们还需要让人工智能知道**如何去评估哪些走法比较好**（走哪步可以绝杀对方，赢得这次下棋；如何应将；如何多吃对方的棋子；如何不浪费自己的棋子这些东西都需要考虑），如果人工智能连评估哪些走法好都不会，和他下棋有什么意义？

最后我们再教会简易的象棋电脑**如何把最好的走法下出来**，这样就可以实现一个简易的人工智能了！

## 开始操作

根据刚才的一阵思考，我们可以使用面向对象的编程思想，来实现这个东西。
**我们使用Board类来承担游戏面板的责任，玩家下棋的操作，人工智能响应玩家下棋都由他实现。**

既然已经准备好理论基础，开始操作！首先请自行准备象棋棋盘的素材，并用lua的全局变量储存所有的象棋棋子的id，为了方便，代码如下：

```lua
R_PAWN = 2023
R_ROOK = 2021
R_KNIGHT = 2018
R_CANNON = 2017
R_BISHOP = 2015
R_GUARD = 2012
R_KING = 2011

B_PAWN = 2022
B_ROOK = 2020
B_KNIGHT = 2019
B_CANNON = 2016
B_BISHOP = 2014
B_GUARD = 2013
B_KING = 2010
```

> id以前缀 R_ 和 B_ 分棋子所属的队伍
> R_  是红方棋子前缀
> B_ 是黑方棋子前缀
>  PAWN 兵 ROOK 车 KNIGHT 马 CANNON 炮
> BISHOP 相  GUARD 士 KING 帅

既然Board是一个类，那么这个类就有他的**构造函数**。首先，先想一想我们要给Board类存一些什么东西呢？

首先，Board承担游戏面板的角色，维护的是一个迷你世界的象棋棋盘，因此Board类应该有成员变量分别储存**棋盘的起始位置s_x,s_z,棋盘结束位置e_x, e_z, 棋盘高度 _y**

其次，我们还需要知道当前是红方下棋还是黑方下棋，也就是说轮到谁的回合，我们需要一个布尔成员变量**isRedTurn储存当前下棋回合**,true表示当前是红方回合，false表示当前是黑方回合

接着，我们可以另外准备一个**数组成员变量g_moves，储存游戏的下棋过程**，这样如果玩家想悔棋，就方便操作多了，我们还可以添加一个**latestPosX,latestPosZ来储存上一步棋子移动的位置**，这样就更方便悔棋了！

实际上，我们还需要使用一个**二维数组boardtable来储存一个象棋棋盘**，因为我们之后需要电脑获得所有的走法，并且我们还规定这个**boardtable\[1]\[1]储存的是象棋棋盘左下角(红方左手边车的位置)的位置，boardtable\[9]\[10]储存的是象棋棋盘右上角（黑方左手边车的位置）的位置**，这样我们就可以用一个二维数组来储存一个象棋棋盘了！

（图片来自网络）

![chinese_chess_start](https://s1.ax1x.com/2022/06/18/XLMC0P.jpg)

因此Board类的构造函数就长这样：

```lua
Board = {}

-- Board构造函数
-- @param s_x, s_z 棋盘起始位置
-- @param e_x, e_z 棋盘结束位置
-- @param _y棋盘的高
function Board:new(s_x, s_z, e_x, e_z, _y)
    self.__index = self
    local self = setmetatable({}, self);

    -- 棋盘起始位置s_x,s_z, 
    -- 结束位置 e_x, e_z
    -- 棋盘高度 _y
    self.s_x = s_x; 
    self.s_z = s_z;
    self.e_x = e_x;
    self.e_z = e_z;
    self._y = _y;
    self.g_moves = {}; -- 储存下棋过程
    -- isRedTurn 是否是红方回合
    self.isRedTurn = true;
     -- boardtable棋盘内容
    self.boardtable = {};

    -- latestPosX 最后下棋的x坐标 latestPosZ 最后下棋的z坐标
    self.latestPosX = -1;
    self.latestPosZ = -1;

    return self;
end

-- 重设Board对象储存的棋盘数组
-- 储存数据为象棋棋盘开局的各棋子位置
function Board:setDefaultBoard()
    self.boardtable = {
        {R_ROOK, 0, 0, R_PAWN, 0, 0, B_PAWN, 0, 0, B_ROOK},
        {R_KNIGHT, 0, R_CANNON, 0, 0, 0, 0, B_CANNON, 0, B_KNIGHT},
        {R_BISHOP, 0, 0, R_PAWN, 0, 0, B_PAWN, 0, 0, B_BISHOP},
        {R_GUARD, 0, 0, 0, 0, 0, 0, 0, 0, B_GUARD},
        {R_KING, 0, 0, R_PAWN, 0, 0, B_PAWN, 0, 0, B_KING},
        {R_GUARD, 0, 0, 0, 0, 0, 0, 0, 0, B_GUARD},
        {R_BISHOP, 0, 0, R_PAWN, 0, 0, B_PAWN, 0, 0, B_BISHOP},
        {R_KNIGHT, 0, R_CANNON, 0, 0, 0, 0, B_CANNON, 0, B_KNIGHT},
        {R_ROOK, 0, 0, R_PAWN, 0, 0, B_PAWN, 0, 0, B_ROOK}
    };
end
```

在上面那段代码中，如果某个位置上没有棋子，存储的0,否则存储的是迷你世界象棋棋子方块对应的id

下一篇文章阐述储存走法思路

###### [回到目录](/docs/development/case/ChineseChess/README.md)

> 作者 吉魂幽
>
> 迷你号 1125833883
>
> ![logo](https://s1.ax1x.com/2022/06/18/XLMPTf.png)
