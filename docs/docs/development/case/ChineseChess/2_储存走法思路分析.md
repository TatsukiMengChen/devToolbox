# 储存走法思路分析

> 想必各位都想建一个简易的人工象棋自己玩玩吧，那么我们应该怎么做呢？让我们一起看看吧！

此类文章记录了如何徒手撸一个迷你世界的一个中国象棋简易象棋人工智能，阅读完这些文章，你将有能力自己写一个属于你自己的象棋电脑！

## 小试身手

上一篇讲述了简易的象棋AI的构造函数，接下来我们开始弄一下如何让电脑知道如何获得当前回合所有棋子的走法吧！

我们应该储存所有棋子的走法存到一个数组里面，那么我们是不是应该先尝试添加棋盘上的每个棋子的所有走法进入到那个数组里面，那么我们就可以准备一个Board:appendPieceMoves函数来添加单个棋子的所有走法进去，于是看代码：

```lua
-- 用于向一个数组添加某一棋子的所有走法
-- @param moves 要添加棋子走法的数组
-- @param x,z 被添加的棋子位置
-- @param thisid 被添加棋子的id
function Board:appendPieceMoves(moves, x, z, thisid)
    -- 判断棋子id，来决定添加棋子的所有走法的添加方式
    -- 由于添加红黑方棋子车，马，炮的行走在算法上代码非常相近，
    -- 所以添加棋子车马炮的行走方式不需要区分是哪方棋子的行走方式
    if (thisid == R_ROOK or thisid == B_ROOK) then
        -- 添加棋子车的所有走法
    elseif (thisid == R_KNIGHT or thisid == B_KNIGHT) then
        -- 添加棋子马的所有走法
    elseif (thisid == R_CANNON or thisid == B_CANNON) then
        -- 添加棋子炮的所有走法
    elseif (thisid == R_GUARD) then
        -- 添加棋子仕的所有走法
    elseif (thisid == B_GUARD) then
        -- 添加棋子士的所有走法
    elseif (thisid == R_KING) then
        -- 添加棋子帅的所有走法
    elseif (thisid == B_KING) then
        -- 添加棋子将的所有走法
    elseif (thisid == R_PAWN) then
        -- 添加棋子兵的所有走法
    elseif (thisid == B_PAWN) then
        -- 添加棋子卒的所有走法
    elseif (thisid == R_BISHOP) then
        -- 添加棋子相的所有走法
    elseif (thisid == B_BISHOP) then
        -- 添加棋子象的所有走法
    end
end
```

那么我们就可以添加一个Board:getAllMoves(isRedTurn)成员函数，这个函数返回一个数组，存储了某方玩家可以下棋的所有走法，看函数实现

```lua
-- RED_ARMY 所有红方棋子的集合
RED_ARMY = {
    [R_PAWN] = 1,
    [R_ROOK] = 1, [R_KNIGHT] = 1, [R_CANNON] = 1, 
    [R_BISHOP] = 1, [R_GUARD] = 1, [R_KING] = 1,
    __index = function() return 0 end
}
setmetatable(RED_ARMY, RED_ARMY)

-- BLACK_ARMY 所有黑方棋子集合
BLACK_ARMY = {
    [B_PAWN] = 1,
    [B_ROOK] = 1, [B_KNIGHT] = 1, [B_CANNON] = 1,
    [B_BISHOP] = 1, [B_GUARD] = 1, [B_KING] = 1
}


-- 获得可以行走的所有走法
-- @param isRedTurn 获取哪方的走法
function Board:getAllMoves(isRedTurn)
    local all_moves = {};
    for i = 1, 9 do
        for j = 1, 10 do
            local pieceid = self.boardtable[i][j];
            if (isRedTurn) then
                -- 要获得红方的所有走法，就判断棋子是否属于红方
                -- 然后调用Board:appendPieceMoves函数添加
                -- 某个位置上棋子的所有走法到数组里面
                if (RED_ARMY[pieceid]) then
                    self:appendPieceMoves(
                        all_moves, i, j, pieceid
                    );
                end
            else
                if (BLACK_ARMY[pieceid]) then
                -- 要获得黑方的所有走法，就判断棋子是否属于黑方
                -- 然后调用Board:appendPieceMoves函数添加
                -- 某个位置上棋子的所有走法到数组里面
                    self:appendPieceMoves(
                        all_moves, i, j, pieceid
                    );
                end
            end
        end
    end
    return all_moves;
end
```

上面那段代码的逻辑很简单，就是遍历boardtable这个储存象棋棋盘的二维数组，根据函数参数进行决定是否要添加那个棋子的所有合法走法进入到数组里面。之后用Board:appendPieceMoves函数来把单个棋子的所有走法都添加到数组里面去，这样我们就可以是电脑获得所有可以走的合法步骤了，简易的完成了！

但是现在Board:appendPieceMoves函数那里实际上并没有添加任何走法进去，只是判断了一下应该添加哪种棋子的走法方式，并没有真正的添加走法进去，因此现在我们现在需要写一下代码，来实现添加走法进去。

## 逐步深入

首先先从添加最简单的棋子兵，卒的走法开始：根据象棋规则，兵，卒没有过河前只能向前走一步，过河之后可以向左向右移动。

所以看添加棋子兵，卒的伪代码：

```lua
-- 添加棋子兵的伪代码
-- this_x 添加棋子走法的x坐标
-- this_z 添加棋子走法的z坐标

-- 在添加棋子的走法之前，
-- 由于棋子只能呆在棋盘里面，并且不能吃自己的棋子，
-- 我们在添加棋子走法之前，需要做很多判断

if (兵前方的位置没有越界) then
    if (兵前方的位置没有越界 and 兵前方的棋子不属于我方的棋子) then
        记录"兵向前走一步"的走法
    end
end
if (兵已经过河) then
    if (兵左边的位置没有越界 and 兵左边的棋子不属于我方的棋子) then
        记录"兵向左走一步"的走法
    end
    if (兵右边的位置没有越界 and 兵右边的棋子不属于我方的棋子) then
        记录"兵向右走一步"的走法
    end
end 
```

定睛一看，好像每次添加棋子的走法都需要判断要记录走法的位置是否越界，并且是否吃掉了我方的棋子，非常的麻烦。既然每次记录一个走法都要判断这些东西之后才会记录，为什么不把这个片段封装成函数呢？这样代码更简洁！

于是有了Board:attack函数，用于尝试记录一下棋子走到那里的走法，如果准备记录到那个位置的走法违反规则，就不会记录走法，否则相反。

问题来了：如何表示一个棋子的行走方式呢？在这里我们可以**使用一个table来表示棋子的行走方式**，这个table有 thisid, killid, s_x, s_z, e_x, e_z这六个信息，**分别储存了被移动棋子的id，移动之后将要吃掉的棋子id,被移动棋子的x坐标,z坐标，被移动棋子移动后的x坐标，z坐标**。如果这个行走方式没有吃掉一个棋子，killid的值就是NO_PIECE,也就是0

所以，Board:attack函数实现如下：

```lua
-- 用于尝试添加一个走法到moves数组里面
-- @param moves 被添加数据的数组
-- @param attack_x, attack_z 移动到的棋子位置
-- @param thisid 被移动棋子的id
-- @return bool 移动棋子移动到的位置是否有棋子存在，或者那个位置越界
function Board:attack(moves, attack_x, attack_z, thisid)
    -- 检测该位置是否越界,越界返回true
    if (attack_x < 1 or attack_x > 9 or attack_z < 1 or attack_z > 10) then
        return true;
    end

    -- 获得该位置棋子id
    local killid = self.boardtable[attack_x][attack_z];    
    -- 判断棋子是否是一队的,防止杀队友
    if (READ_ARMY[thisid] == READ_AEMY[killid])then
        return true;
    end

    table.insert(moves, 
    {      -- 储存move
        thisid = thisid, killid = killid,
        s_x = self.this_x,  s_z = self.this_z, 
        e_x = attack_x, e_z = attack_z
    });
    if (NO_PIECE == killid) then
        return false; -- 攻击到空白位置
    end
    -- 攻击到敌方棋子
    return true;
end
```

因此我们就可以这样添加棋子兵，卒的走法：

```lua
    if (thisid == R_PAWN) then
    -- 添加红方棋子兵的走法
        if (z > 5) then 
        -- 如果兵过河，就尝试使兵左右走
            self:attack(moves, x + 1, z, thisid);
            self:attack(moves, x - 1, z, thisid);
        end
        -- 尝试使兵向前走一步
        self:attack(moves, x, z + 1, thisid);
        return;
    end

    if (thisid == B_PAWN) then
    -- 添加黑方棋子卒的走法
        if (z < 6) then
        -- 如果卒过河，就尝试使兵左右走
            self:attack(moves, x + 1, z, thisid);
            self:attack(moves, x - 1, z, thisid);
        end
        -- 尝试使卒向前走一步
        self:attack(moves, x, z - 1, thisid);
        return;
    end
```

同理，添加棋子仕和士的走法也很好理解了，我们只需要在棋子仕和士在快出九宫的时候阻止他们出九宫就可以了，

```lua
    if (thisid == R_GUARD) then -- 红仕
        local not_cross_front = (z < 3) -- 是否出九宫顶部

        if (x > 4) then -- 是否出九宫左侧
            self:attack(moves, x - 1, z - 1, thisid);
            if (not_cross_front) then
                self:attack(moves, x - 1, z + 1, thisid);
            end
        end
        if (x < 6) then -- 是否出九宫右侧
            self:attack(moves, x + 1, z - 1, thisid);
            if (not_cross_front) then
                self:attack(moves, x + 1, z + 1, thisid);
            end
        end
        return;
    end

    if (thisid == B_GUARD) then -- 黑士
        local not_cross_back = (z > 8); -- 是否出九宫顶部

        if (x > 4) then -- 是否出九宫左侧
            self:attack(moves, x - 1, z + 1, thisid);
            if (not_cross_back) then
                self:attack(moves, x - 1, z - 1, thisid);
            end
        end
        if (x < 6) then -- 是否出九宫右侧
            self:attack(moves, x + 1, z + 1, thisid);
            if (not_cross_back) then
                self:attack(moves, x + 1, z - 1, thisid);
            end
        end
        return;
    end
```

下一篇阐述添加棋子车马炮相帅的棋子走法

###### [回到目录](/docs/development/case/ChineseChess/README.md)

> 作者 吉魂幽
>
> 迷你号 1125833883
>
> ![logo](https://s1.ax1x.com/2022/06/18/XLMPTf.png)
