# 储存走法思路分析_2

> 想必各位都想建一个简易的人工象棋自己玩玩吧，那么我们应该怎么做呢？让我们一起看看吧！

此类文章记录了如何徒手撸一个迷你世界的一个中国象棋简易象棋人工智能，阅读完这些文章，你将有能力自己写一个属于你自己的象棋电脑！

## 更进一步

上一篇讲述了如何获得象棋所有棋子的走法。接下来让我们继续想办法储存棋子车马炮相帅的棋子走法吧！

添加棋子马的走法非常简单，首先先判断有没有“蹩马腿”，如果没有则可以移动，于是：

```lua
    if (thisid == R_KNIGHT or thisid == B_KNIGHT) then
    -- 添加棋子马的走法
        if self:isFreeSpace(x - 1, z) then -- 判断马脚
            self:attack(moves, x - 2, z + 1, thisid);
            self:attack(moves, x - 2, z - 1, thisid);
        end
        if self:isFreeSpace(x + 1, z) then -- 判断马脚
            self:attack(moves, x + 2, z + 1, thisid);
            self:attack(moves, x + 2, z - 1, thisid);
        end
        if self:isFreeSpace(x, z - 1) then -- 判断马脚
            self:attack(moves, x + 1, z - 2, thisid);
            self:attack(moves, x - 1, z - 2, thisid);
        end
        if self:isFreeSpace(x, z + 1) then -- 判断马脚
            self:attack(moves, x + 1, z + 2, thisid);
            self:attack(moves, x - 1, z + 2, thisid);
        end
        return;
    end
```

这里引入了一个新函数，Board:isFreeSpace，这个函数用于判断棋盘上某个位置是否有棋子，如果有棋子，就返回false，否则返回true，如果判断的位置越界了，返回false。Board:isFreeSpace函数定义如下:

```lua
-- 判断棋盘某个位置是否有棋子存在
-- @return bool 是否有棋子存在
function Board:isFreeSpace(attack_x, attack_z)
    if (attack_x < 1 or attack_x > 9 or attack_z < 1 or attack_z > 10) then
        return false;
    end
    return (NO_PIECE == self.boardtable[attack_x][attack_z]);
end
```

同样的方法，添加棋子相和象的走法就很好理解了，就和棋子仕一样，在相快过河的时候就阻止棋子过河就可以了，于是：

```lua
    if (thisid == R_BISHOP) then -- 添加红相的走法
        if (z  < 5) then -- 阻止相过河
            if self:isFreeSpace(x + 1, z + 1) then 
            -- 如果有棋子卡住了象眼，阻止飞象
                self:attack(moves, x + 2, z + 2, thisid);
            end
            if self:isFreeSpace(x - 1, z + 1) then 
            -- 如果有棋子卡住了象眼，阻止飞象
                self:attack(moves, x - 2, z + 2, thisid);
            end
        end
        if self:isFreeSpace(x + 1, z - 1) then 
        -- 如果有棋子卡住了象眼，阻止飞象
            self:attack(moves, x + 2, z - 2, thisid);
        end
        if self:isFreeSpace(x - 1, z - 1) then 
        -- 如果有棋子卡住了象眼，阻止飞象
            self:attack(moves, x - 2, z - 2, thisid);
        end
        return;
    end

    if (thisid == B_BISHOP) then -- 添加黑象的走法
        if (z > 6) then -- 阻止象过河
            if self:isFreeSpace(x + 1, z - 1) then 
            -- 检查象眼
                self:attack(moves, x + 2, z - 2, thisid);
            end
            if self:isFreeSpace(x - 1, z - 1) then 
            -- 检查象眼
                self:attack(moves, x - 2, z - 2, thisid);
            end
        end
        if self:isFreeSpace(x + 1, z + 1) then -- 检查象眼
            self:attack(moves, x + 2, z + 2, thisid);
        end
        if self:isFreeSpace(x - 1, z + 1) then -- 检查象眼
            self:attack(moves, x - 2, z + 2, thisid);
        end
        return;
    end
```

## 重头戏

接下来到重头戏，棋子车和炮的走法：

棋子马，相，兵的走法记录起来都很简单，但是对于车，炮这种棋子，记录他的走法似乎变得很难，因为他们走法几乎都是可以**水平或垂直方向移动任意个无阻碍的点**。有那么多点都需要记录，但是我们如何知道怎么记录呢？如何判断水平或垂直方向移动任意个无阻碍的点有哪些呢？

对于棋子车，我们以这个棋子**车他的上下左右四个方向，用循环来一个一个位置的判断前方有没有棋子阻挡**，如果没有就可以走到那个位置，否则就判断一下那个棋子能不能被我方棋子吃掉，如果能吃掉，就记录这个走法，最后结束记录。这样就完成了

作者之前特地准备了一个attack函数，他记录棋子移动那里的走法之后，还有一个返回值表示那个位置是否有棋子或者是否越界，于是通过那个返回值，就好办了：

```lua
-- 临时函数AddRookMove,用于添加棋子车的走法
-- @param x,z 棋子自身的位置
-- @param v_x, v_z 一个x轴方向 和 一个z轴方向
local function AddRookMove(x, z, v_x, v_z)
    -- 尝试攻击敌方棋子
    for i = 1, 9 do
       -- 与方向v_x, v_z 运算获得应该攻击的位置
       local l_x = x + i * v_x;
       local l_z = z + i * v_z;
       -- 判断那个位置是否有棋子或者越界，
       -- 如果有棋子或越界，就停止记录
       -- 这样就可以得到所有 水平或垂直方向移动任意个无阻碍的点
       if (self:attack(moves, l_x, l_z, thisid) ) then
           return;
        end
   end
   return;
end

if (thisid == R_ROOK or thisid == B_ROOK) then
   -- 添加棋子车的走法
   AddRookMoves(x, z, 1, 0);
   AddRookMoves(x, z, -1, 0);
   AddRookMoves(x, z,  0, 1);
   AddRookMoves(x, z,  0, -1);
   return;
end
```

对于棋子炮的走法，我们需要找炮架，同样是上下左右四个方向寻找无阻碍的点，但是**找到之后我们需要再次使用这个方法，寻找炮应该打击的点**，这样就轻松解决了：

```lua
-- 临时函数AddRookMove,用于添加棋子炮的走法
-- @param x,z 棋子自身的位置
-- @param v_x, v_z 一个x轴方向 和 一个z轴方向
local function AddCannonMoves(x, z, v_x, v_z)
    for i = 1, 9 do
        -- 与方向v_x, v_z 运算获得应该攻击的位置
        local l_x = x + i * v_x;
        local l_z = z + i * v_z;
        -- 若攻击的位置没有空位(找到了炮架)
        if (not self:isFreeSpace(l_x, l_z) ) then
            -- 尝试攻击一个棋子
            for j = i + 1, 9 do
                l_x = x + j * v_x;
                l_z = z + j * v_z;
                -- 若找到了可以攻击的地方,就尝试攻击,然后返回
                if (not self:isFreeSpace(l_x, l_z) ) then
                    self:attack(moves, l_x, l_z, thisid);
                    return;
                end
            end
        -- 否则攻击空位置
        else
            self:attack(moves, l_x, l_z, thisid);
        end
    end
end

if (thisid == R_CANNON or thisid == B_CANNON) then
   -- 添加棋子炮的走法
   AddCannonMoves(x, z, 1, 0, false);
   AddCannonMoves(x, z, -1, 0, false);
   AddCannonMoves(x, z,  0, 1, false);
   AddCannonMoves(x, z,  0, -1, false);
   return;
end
```

之后还剩棋子帅和将的走法，和棋子仕一样，在帅快出九宫的时候限制一下帅的行走即可，还有帅的对面笑规则，其实就和棋子车一样的寻找方法，只不过这时候的帅是被削弱的车，只能飞身攻击棋子帅/将、

```lua
if (thisid == R_KING) then -- 红帅
        for i = 1, 9 do -- 飞将
            if (not self:isFreeSpace(x, z + i) ) then
                if (self.boardtable[x][z + i] == B_KING) then
                    self:attack(moves, x, z + i, thisid);
                end
                break;
            end
        end

        self:attack(moves, x, z - 1, thisid);
        if (x > 4) then -- 是否出九宫左侧
            self:attack(moves, x - 1, z, thisid);
        end
        if (x < 6) then -- 是否出九宫右侧
            self:attack(moves, x + 1, z, thisid);
        end
        if (z < 3) then -- 是否出九宫顶部
            self:attack(moves, x, z + 1, thisid);
        end
        return;
    end

    if (thisid == B_KING) then -- 黑将
        for i = 1, 9 do -- 飞将
            if (not self:isFreeSpace(x, z - i) ) then               
                if (self.boardtable[x][z + i] == R_KING) then
                    self:attack(moves, x, z - i, thisid);
                end
                break;
            end
        end

        self:attack(moves, x, z + 1, thisid);
        if (x > 4) then -- 是否出九宫左侧
            self:attack(moves, x - 1, z, thisid);
        end
        if (x < 6) then -- 是否出九宫右侧
            self:attack(moves, x + 1, z, thisid);
        end
        if (z > 8) then -- 是否出九宫顶部
            self:attack(moves, x, z - 1, thisid);
        end
        return;
    end
```

通过上述步骤，就完成了获取某一方所有可行走法的操作，下一篇文章将实现玩家与游戏面板交互和电脑响应玩家下棋。

###### [回到目录](/docs/development/case/ChineseChess/README.md)

> 作者 吉魂幽
>
> 迷你号 1125833883
>
> ![logo](https://s1.ax1x.com/2022/06/18/XLMPTf.png)
