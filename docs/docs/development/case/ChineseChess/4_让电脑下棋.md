# 让电脑下棋

> 想必各位都想建一个简易的人工象棋自己玩玩吧，那么我们应该怎么做呢？让我们一起看看吧！

此类文章记录了如何徒手撸一个迷你世界的一个中国象棋简易象棋人工智能，阅读完这些文章，你将有能力自己写一个属于你自己的象棋电脑！

## 不断前进

上一篇文章已经实现了如何让电脑获得某方所有可行的下棋走法，那么我们现在可以再写一下代码来看一下下棋效果

首先，先给电脑提供一个如何下棋的方法，我们决定提供一个Board:doMove(move)函数，参数move是一个描绘象棋走法的table，调用这个函数，电脑就可以把他的下棋表现在迷你世界游戏里面了。稍微思考，即可得到：

```lua
-- 用于在游戏中真正的走棋
-- @param move 棋子的走法
function Board:doMove(move)
    -- 调用这个函数会在迷你世界的象棋棋盘下一步棋
    -- 调这个函数会播放下棋特效
    
    -- 在位置上取消先前下棋的特效
    World:stopEffectOnPosition(self.latestPosX, 
        self._y, elf.latestPosZ, 1170, 0.5)
    
    local diction = DICTION_BLACK;
-- 设置棋子方向
-- 红棋的方向和黑棋的方向均已确定, 只需简单的判断来确定棋子方向
    if (self.isRedTurn) then
        diction = DICTION_RED;
    end

    -- 将储存在对象中的走法在实际局面中表现出来
    -- beg_x, beg_z 被移动棋子x坐标, z坐标
    -- end_x, end_z 移动到的位置x坐标, z坐标
    local beg_x = self.s_x + move.s_x - 1;
    local beg_z = self.s_z + move.s_z - 1;
    local end_x = self.s_x + move.e_x - 1;
    local end_z = self.s_z + move.e_z - 1;

    self.latestPosX = beg_x;
    self.latestPosZ = beg_z;
    -- 模拟移动棋子
    Block:setBlockAll(end_x, self._y, end_z, move.thisid, diction);
    -- 摧毁原先位置的棋子
    Block:destroyBlock(beg_x, self._y, beg_z, false);
    -- 播放下棋的特效，便于玩家发现下棋了
    World:playParticalEffect(self.latestPosX, 
        self._y, self.latestPosZ, 1170, 0.5);
    
    -- Board:makeMove
    -- 这个函数用于储存下棋过程，因为可能玩家想悔棋
    self:makeMove(move);
    
    -- 转换回合
    self.isRedTurn = not self.isRedTurn;
end


-- 用于AI储存棋局的走棋
function Board:makeMove(move)
    -- 储存下棋
    table.insert(self.g_moves, move);
    self.boardtable[move.s_x][move.s_z] = NO_PIECE;
    self.boardtable[move.e_x][move.e_z] = move.thisid;
end
```

可以下棋肯定也能悔棋，于是有了悔棋函数 Board:undoMove()

```lua
-- 用于在游戏中真正的悔棋
function Board:undoMove()
    -- 获得上一次走的棋
    local move = self.g_moves[#self.g_moves];
    -- 获得移动棋子的方向 diction
    -- 获得被吃掉棋子的方向 k_diction
    local diction = DICTION_BLACK;
    local k_diction = DICTION_RED;

    if (self.isRedTurn) then
        diction = DICTION_RED;
        k_diction = DICTION_BLACK;
    end

    -- 将悔棋结果表现出来
    -- beg_x, beg_z 被移动棋子x坐标, z坐标
    -- end_x, end_z 移动到的位置x坐标, z坐标
    local beg_x = self.s_x + move.s_x - 1;
    local beg_z = self.s_z + move.s_z - 1;
    local end_x = self.s_x + move.e_x - 1;
    local end_z = self.s_z + move.e_z - 1; 

    -- 摆放棋子到移动之前的位置
    Block:setBlockAll(beg_x, self._y, beg_z, move.thisid, diction);
    if ( move.killid == NO_PIECE ) then                 -- 如果最近的下棋没有吃棋子，把原先位置的棋子摧毁即可
        Block:destroyBlock(end_x, self._y, end_z, false);
    else
    -- 否则使被吃掉的棋子复活
        Block:setBlockAll(end_x, self._y, end_z, move.killid, k_diction);
    end  

    -- 删去最近的走起
    self:unmakeMove();
    -- 游戏回合转换
    self.isRedTurn = not self.isRedTurn;
end
```

接下来，作者认为提供一个Board:doGameLoop()函数，之后先创建出一个Board对象，再调用他的doGameLoop函数使玩家与棋盘交互，玩家与电脑交互下棋的这个思维比较好，于是有了doGameLoop函数来实现玩家与电脑下棋

```lua
-- 用于使外界进行交互下棋
function Board:doGameLoop()
    local turn_moves = {};
    -- turn_moves用于储存玩家回合的选择棋子
    
    -- 监听事件玩家点击方块,以此来模拟移动棋子,选择棋子的效果
    ScriptSupportEvent:registerEvent("Player.ClickBlock", function(e)
        -- 判断电脑是否正在思考
        if (self.isThinking) then
            Chat:sendSystemMsg("电脑正在思考")
            return;
        end
        -- 判断点击位置是否出界
        if (self.s_x > e.x or self.s_z > e.z or 
           self.e_x < e.x or self.e_z < e.z) then
            return;
        end

        -- 迷你世界的坐标转成棋盘所用的坐标体系
        local real_x = e.x - self.s_x + 1;
        local real_z = e.z - self.s_z + 1;

        -- 使玩家选择棋子如果他选择正确的棋子, 双重检测,以防外挂
        if (VAL[e.blockid] < 0 and 
            self.boardtable[real_x][real_z] == e.blockid) then
            Chat:sendSystemMsg("您已选中棋子");
            turn_moves = {};
            self:appendPieceMoves(
                turn_moves, real_x, real_z, e.blockid
            );
            return;
        end

        -- 判断玩家点击位置是否是可以下棋的地方
        for key, move in ipairs(turn_moves) do
            if (move.e_x == real_x and move.e_z == real_z) then
                -- 玩家下棋
                self:doMove(move);
                turn_moves = {};
                -- 使电脑下棋
                self:letComputerMove();
                return;
            end
        end

    end);
end
```

上面的代码调用了Board:letComputerMove函数来使电脑下棋响应玩家下棋操作但是目前还没有定义，于是：

```lua
-- 用于AI下棋
function Board:letComputerMove()
    self.isThinking = true;
    -- 目前让电脑下棋，就是让电脑获得所有电脑可以的走法
    -- 然后随机选择一个来下
    local best_moves = self:getAllMoves(self.isRedTurn);
    self:doMove(best_moves[math.random(1, #best_moves) ]);
    self.isThinking = false;
end
```

这样，一个简单的人机就做好了，他可以和玩家下棋哦！拷贝代码到游戏运行，就可以体验效果了。现在电脑只是随机走几步棋，棋艺太逊，接下来让我们提高一下简易的象棋人机水平吧！

## 考虑一步的人工智能

电脑的优势在于强大的计算能力，虽然电脑不知道怎么走合适，但是她有强大的计算能力，能够快速计算，非常快的模拟出很多情况，之后再决定走哪步。

###### [回到目录](/docs/development/case/ChineseChess/README.md)


> 作者 吉魂幽
>
> 迷你号 1125833883
>
> ![logo](https://s1.ax1x.com/2022/06/18/XLMPTf.png)
